# Tiered Note Commitment Tree

## Motivation and Relevant Context

Since transactions in Penumbra are shielded, an output of a transaction is a cryptographic
commitment to a [note](../concepts/notes_nullifiers_trees.md), not a note itself. These note
commitments are stored in the tiered commitment tree described in this section, which is replicated
across all nodes and clients.

A client spends a note by using the note commitment tree to produce a (zero knowledge) proof that
the note's commitment was included in the tree, using their spending key to demonstrate that they
are authorized to spend that note, and revealing the note's unique nullifier, to prevent the same
note from ever being spent again.

In this section, we will focus on the design of a commitment tree which enables it to be efficiently
replicated across nodes and clients, and to produce these zero-knowledge proofs of inclusion
required to spend notes.

Penumbra, like many blockchains, divides time into _epochs_, each of which is divided into _blocks_,
each of which contains some number of _transactions_. From the perspective of the note commitment
tree, the only salient aspect of a transaction is its list of _outputs_. Each output contains a
commitment to a specific note. The note commitment tree's purpose is to store all of these
commitments in a way that allows proofs of inclusion to be generated by the client for any unspent
note commitment they possess.

In order to build zero-knowledge proofs of inclusion in the tree, it needs to use a hash function
compatible with the SNARK system in use. While the [Poseidon hash function](./poseidon.md) used in
the tree is friendly to use in SNARKs, it is approximately 1,000 times more expensive to compute in
software than ordinary, non-SNARK-friendly hashes. As a result, the computation of hashes dominates
the cost of any note commitment tree design. In order to allow for fast synchronization, the
efficient note commitment tree used in Penumbra is:

- __tiered__, allowing the root hash of a block or an epoch to be added at the same cost as an
  individual commitment, which means the client can skip over blocks or epochs containing nothing of
  interest to them while computing many orders of magnitude fewer hashes;
- __sparse__, representing only the information necessary to construct the proofs for the client (or
  in the case of the node, the minimum information necessary to compute new root hashes, because
  nodes never need to create proofs themselves), and not information pertaining to note commitments
  unrelated to a given client;
- __incremental__, so that new note commitments can be added in amortized constant time, regardless of
  the size of the tree; and
- __lazy__, computing expensive hash operations only when absolutely necessary, and caching their
  results as much as possible.

Of these important attributes, only the first two (_tiered_ and _sparse_) are in scope for this
section. The abstract tree described here is meant to precisely specify how the tree structure is
generated and hashed, but is not meant to describe how the implementation is optimized beyond that.

## The Rest Of This Section

1. We first specify the [tiered structure](#tiered-structure) of the tree without describing anything
about hashing as a function from epochs full of blocks full of commitments;
2. Then, we specify the [hashing](#hashing-nodes) of each node in the tree as an inductive function
on the tree structure;
3. Finally, we describe how the tree can be made [sparse](#sparsity) by describing a modification to
the original construction algorithm, and showing how this modification does not change the hashes of
any nodes which remain in the tree.

## Tiered Structure

At any given moment in time, the aggregate of all note commitments produced in the history of the
chain can be thought of as a triply-nested sequence (an _eternity_) of sequences (_epochs_) of
sequences (_blocks_) of note commitments (hereafter: _commitments_). The specific representation of
a commitment is discussed in [hashing nodes](#hashing-nodes); it is not relevant to this subsection.

## Hashing Nodes

Each commitment is represented by a single element from the $\mathbb{F}_q$ field of
[BLS12-377](https://docs.rs/ark-ed-on-bls12-377/0.3.0/ark_ed_on_bls12_377/). The [Poseidon for
BLS12-377](./poseidon.md) hash function is defined over that same field.

### Elementary Hashes and Domain Separators

We define the hash of each node in the tree in terms of two arities of the Poseidon hash function:

- $\mathtt{hash_1} : \mathbb{F}_q \times \mathbb{F}_q \to \mathbb{F}_q$
- $\mathtt{hash_4} : \mathbb{F}_q \times (\mathbb{F}_q \times \mathbb{F}_q \times \mathbb{F}_q
  \times \mathbb{F}_q) \to \mathbb{F}_q$

Each of these takes as its first argument a _domain separator_. For the tiered note commitment tree,
we use a domain separator calculated in terms of the _base domain separator_ $\mathbf{D}_0 =
\mathtt{blake2b}(\mathtt{"penumbra.tct"})$ interpreted in little-endian order as an element of
$\mathbb{F}_q$, i.e. the following hash output from
[BLAKE2](https://datatracker.ietf.org/doc/html/rfc7693):

```plain_text
0x197e501077d94b004b29e91196b9da397b8acbc98ac2d13d9099ad99f5215e490f171a0406f223ed25bafe4bc0451b649ba4b3fe0374d4a0b1ffd2ead37f531e
```

...interpreted as a (large) integer in little-endian order, and reduced by the modulus of
$\mathbb{F}_q$.

In terms of this base domain separator, we construct a separate domain separator to use for each
_height_ of node or leaf in the tree. The height of a leaf is defined as zero, and the height of a
node is defined as one greater than the height of its children (therefore the lowest node in the
tree has height 1).

$$\mathbf{D}_\mathtt{height} = \mathbf{D}_0 + \mathtt{height}$$

We then define the hash functions for leaves and nodes in terms of the original $\mathtt{hash_1}$ and
$\mathtt{hash_4}$ functions from Poseidon:

- $\mathtt{hash_{leaf}}(\mathtt{commitment} : \mathbb{F}_q) = \mathtt{hash_1}(\mathbf{D}_0,
\mathtt{commitment})$
- $\mathtt{hash_{node}}(\mathtt{height} : \mathbb{N}, \mathtt{children} : \mathbb{F}_q \times
\mathbb{F}_q \times \mathbb{F}_q \times \mathbb{F}_q) = \mathtt{hash_4}(\mathbf{D}_\mathtt{height},
\mathtt{children})$

Having defined them, we will now exclusively use $\mathtt{hash_{leaf}}$ and $\mathtt{hash_{node}}$.

### Hashes of Leaves

Leaves are easy to hash; every leaf's hash is the $\mathtt{hash_{leaf}}$ of its contained commitment.

### Hashes of Nodes

The hash of a node is dependent on three things:

1. its _height_,
2. whether it is on the _frontier_ of the tree, and
3. the hashes of its children.

#### Frontier-Dependent Padding

Recall that each node may have any of $\{0 \dots 4\}$ children, inclusive. However, recall the node
hash function $\mathtt{hash_{node}} : \mathbb{N} \times (\mathbb{F}_q \times \mathbb{F}_q \times
\mathbb{F}_q \times \mathbb{F}_q) \to \mathbb{F}_q$ is of fixed arity: it requires precisely a node height and 4
child hashes. In order to take the hash of a node, we need to _pad_ its list of children with some
padding element $\mathbf{P}$:

$$
\begin{align}
\mathtt{pad}_4(\mathbf{P}, & []) & =\ \ & (\mathbf{P}, \mathbf{P}, \mathbf{P}, \mathbf{P}) \newline
\mathtt{pad}_4(\mathbf{P}, & [a]) & =\ \ & (a, \mathbf{P}, \mathbf{P}, \mathbf{P}) \newline
\mathtt{pad}_4(\mathbf{P}, & [a, b]) & =\ \ & (a, b, \mathbf{P}, \mathbf{P}) \newline
\mathtt{pad}_4(\mathbf{P}, & [a, b, c]) & =\ \ & (a, b, c, \mathbf{P}) \newline
\mathtt{pad}_4(\mathbf{P}, & [a, b, c, d]) & =\ \ & (a, b, c, d) \newline
\end{align}
$$

In order to bind the root hash of the tree to the fact of a given subtree (block, epoch, etc.) being
completed or unfinished, we use a different padding element for computing the hash of nodes on the
_frontier_. A node is considered on the _frontier_ of the tree if __either__:

- it is the root node of the tree, or
- its parent node is on the frontier of the tree and it is the rightmost child of its parent.

If a node is on the frontier, we use the padding element $\mathbf{P}_\mathtt{frontier} :
\mathbb{F}_q = 0$. Otherwise, we use the padding element $\mathbf{P}_\mathtt{complete} :
\mathbb{F}_q = 1$.

#### Hashes of Empty Nodes

The hash of the empty node is defined as $\mathbf{P}_\mathtt{frontier}$ if the node is on the
frontier, and $\mathbf{P}_\mathtt{complete}$ if it is not on the frontier.

#### Hashes of Nodes With Children

The hash of a node with more than zero children is defined as:

$$
\mathtt{node.hash} = \mathtt{hash_{node}}\left(\mathtt{node.height},
\mathtt{pad}_4(\mathbf{P}_{\mathtt{place}(\mathtt{node})}, \mathtt{map}(\lambda \mathtt{c} \to \mathtt{c.hash}, \mathtt{node.children}))\right)
$$

where $\mathtt{place}(\mathtt{node})$ is $\mathtt{frontier}$ or $\mathtt{complete}$, depending on whether the node is on the
frontier or not, and $\mathtt{map}$ maps a function over a list.

## Sparsity
