# Tiered Note Commitment Tree

## Motivation and Relevant Context

Since transactions in Penumbra are shielded, an output of a transaction is a cryptographic
commitment to a [note](../concepts/notes_nullifiers_trees.md), not a note itself. These note
commitments are stored in the tiered commitment tree described in this section, which is replicated
across all nodes and clients.

A client spends a note by using the note commitment tree to produce a (zero knowledge) proof that
the note's commitment was included in the tree, using their spending key to demonstrate that they
are authorized to spend that note, and revealing the note's unique nullifier, to prevent the same
note from ever being spent again.

In this section, we will focus on the design of a commitment tree which enables it to be efficiently
replicated across nodes and clients, and to produce these zero-knowledge proofs of inclusion
required to spend notes.

Penumbra, like many blockchains, divides time into _epochs_, each of which is divided into _blocks_,
each of which contains some number of _transactions_. From the perspective of the note commitment
tree, the only salient aspect of a transaction is its list of _outputs_. Each output contains a
commitment to a specific note. The note commitment tree's purpose is to store all of these
commitments in a way that allows proofs of inclusion to be generated by the client for any unspent
note commitment they possess.

In order to build zero-knowledge proofs of inclusion in the tree, it needs to use a hash function
compatible with the SNARK system in use. While the [Poseidon hash function](./poseidon.md) used in
the tree is friendly to use in SNARKs, it is approximately 1,000 times more expensive to compute in
software than ordinary, non-SNARK-friendly hashes. As a result, the computation of hashes dominates
the cost of any note commitment tree design. In order to allow for fast synchronization, the
efficient note commitment tree used in Penumbra is:

- __tiered__, allowing the root hash of a block or an epoch to be added at the same cost as an
  individual commitment, which means the client can skip over blocks or epochs containing nothing of
  interest to them while computing many orders of magnitude fewer hashes; and
- __sparse__, representing only the information necessary to construct the proofs for the client (or
  in the case of the node, the minimum information necessary to compute new root hashes, because
  nodes never need to create proofs themselves), and not information pertaining to note commitments
  unrelated to a given client.

## The Rest Of This Section

1. We first specify the [tiered structure](#tiered-structure) of the tree without describing anything
about hashing as a function from epochs full of blocks full of commitments;
2. Then, we specify the [hashing](#hashing-nodes) of each node in the tree as an inductive function
on the tree structure;
3. Finally, we describe how the tree can be made [sparse](#sparsity) by describing a modification to
the original construction algorithm, and showing how this modification does not change the hashes of
any nodes which remain in the tree.

## Tiered Structure

At any given moment in time, the aggregate of all note commitments produced in the history of the
chain can be thought of as a triply-nested sequence (an _eternity_) of sequences (_epochs_) of
sequences (_blocks_) of note commitments. The tiered commitment tree represents these triply-nested
sequences as triply-nested tiers.

The entire commitment tree consists of three tiers, each of which is 8 levels tall.

- The entire commitment tree consists of a top-level [_tier_](#tiers) (which we call an _eternity_),
which contains 8 nested levels of [_nodes_](#nodes);
- The children of the bottom-most [_nodes_](#nodes) in an eternity are [_tiers_](#tiers) (which we
  call _epochs_), which each contain 8 nested levels of [_nodes_](#nodes).
- The children of the bottom-most [_nodes_](#nodes) in an epoch are [_tiers_](#tiers) (which we call
  _blocks_), which each contain 8 nested levels of [_nodes_](#nodes).
- The children of the bottom-most [_nodes_](#nodes) in a block are [_leaves_](#leaves) that contain
  one commitment each.

```text
Eternity┃           ╱╲ ◀───────────── Eternity Root
    Tree┃          ╱││╲
        ┃         * ** *           ╮
        ┃      *   *  *   *        │ 8 levels
        ┃   *     *    *     *     ╯
        ┃  ╱╲    ╱╲    ╱╲    ╱╲
        ┃ ╱││╲  ╱││╲  ╱││╲  ╱││╲ ◀─── Epoch Root
                     ┌──┘
                     │
                     │
   Epoch┃           ╱╲ ◀───────────── Epoch Root
    Tree┃          ╱││╲
        ┃         * ** *           ╮
        ┃      *   *  *   *        │ 8 levels
        ┃   *     *    *     *     ╯
        ┃  ╱╲    ╱╲    ╱╲    ╱╲
        ┃ ╱││╲  ╱││╲  ╱││╲  ╱││╲ ◀─── Block Root
                 ▲
                 └───┐
                     │
                     │
   Block┃           ╱╲ ◀───────────── Block Root
    Tree┃          ╱││╲
        ┃         * ** *           ╮
        ┃      *   *  *   *        │ 8 levels
        ┃   *     *    *     *     ╯
        ┃  ╱╲    ╱╲    ╱╲    ╱╲
        ┃ ╱││╲  ╱││╲  ╱││╲  ╱││╲ ◀─── Block Leaf
                                      = Note Commitment
```

As a consequence of this structure, the maximum capacity of a tier is $4^8 = 65,536$, and the
maximum capacity of the entire tree is $4^{3 \cdot 8} = 281,474,976,710,656$.

### Structural Definitions

#### Tiers

A tier is either _empty_ or it is a [_node_](#nodes).

#### Nodes

A node in a tree contains a _non-empty_ list of up to four _children_.

If a node has an $n$th child (for $n > 0$), it must have an $(n - 1)$th child (there cannot be gaps
in the list of children).

Each node must be _left-to-right filled_:

- if its children are nodes, all its children but its rightmost child are _perfect_, and its
  rightmost child is left-to-right filled (where a _perfect_ node has exactly four children and if its
  children are nodes, they are also perfect) or
- if its children are leaves or tiers, the node is left-to-right filled.

#### Leaves

A leaf of a tree is a single commitment.

## Construction

As noted above, the history of all commitments at any point in time is a triply-nested sequence of
commitments, representing epochs, each of which has some number of blocks, each of which has
some number of commitments, each ordered at every level chronologically. We can construct a tiered
commitment tree from this triply nested sequence of commitments by iterating an algorithm to
construct a single tier from a single sequence of items three times, to reduce a triply-nested
sequence of commitments to a triply-nested tiered tree.

We define a function $\mathtt{tier}$ which converts a sequence of items (of length less than $4^8$)
to a tier whose bottom-most nodes' children are those items:

$$
\begin{align}
\mathtt{tier}([]) & = \mathtt{Tier}(\emptyset) \\
\mathtt{tier}(items) & =
\mathtt{Tier}\big(\underset{1}{\mathtt{chunk}}(\underset{2}{\mathtt{chunk}}(\underset{3}{\mathtt{chunk}}(\underset{4}{\mathtt{chunk}}(\underset{5}{\mathtt{chunk}}(\underset{6}{\mathtt{chunk}}(\underset{7}{\mathtt{chunk}}(\underset{8}{\mathtt{chunk}}(items))))))))[0]\big)
\end{align}
$$

where the function $\mathtt{chunk}$ is defined on non-empty sequences as:

$$
\begin{align}
\mathtt{chunk}([a, b, c, d, \dots rest]) & = [\mathtt{Node}(a, b, c, d), \dots \mathtt{chunk}(rest)] \\
\mathtt{chunk}([a, b, c]) & = [\mathtt{Node}(a, b, c)] \\
\mathtt{chunk}([a, b]) & = [\mathtt{Node}(a, b)] \\
\mathtt{chunk}([a]) & = [\mathtt{Node}(a)] \\
\end{align}
$$

In English, this algorithm is:

- if the sequence is empty, return the empty tier;
- otherwise, do the following exactly 8 times:
  - in left to right order, greedily partition the sequence into chunks of at most 4 items, so
    that all but the last chunk has exactly 4 items, and the last chunk has at most 4 items;
  - for each chunk, construct a single node from it; and
  - unless done with the 8 iterations, repeat again, starting with this sequence of nodes (which is
    now shorter by about a factor of 4)
- if the input sequence was less than $4^8$ items long, the resultant sequence will now contain
  exactly one node; return it as the top-most node contained in a tier.

Constructing the entire tree requires mapping the $\mathtt{tier}$ function over the triply-nested
sequence:

$$
\begin{align}
& \mathtt{tree}(eternity) =\\
& \ \ \ \ \mathtt{tier}\left(eternity\mathtt{.map}(epoch \Rightarrow \mathtt{tier}(epoch\mathtt{.map}(block \Rightarrow
\mathtt{tier}(block)))))\right)
\end{align}
$$

where the $\mathtt{map}$ function applies a function to each element of a sequence.

## Hashing Nodes

Each commitment is represented by a single element from the $\mathbb{F}_q$ field of
[BLS12-377](https://docs.rs/ark-ed-on-bls12-377/0.3.0/ark_ed_on_bls12_377/). The [Poseidon for
BLS12-377](./poseidon.md) hash function is defined over that same field.

### Elementary Hashes and Domain Separators

We define the hash of each node in the tree in terms of two arities of the Poseidon hash function:

- $\mathtt{hash_1} : \mathbb{F}_q \times \mathbb{F}_q \to \mathbb{F}_q$
- $\mathtt{hash_4} : \mathbb{F}_q \times (\mathbb{F}_q \times \mathbb{F}_q \times \mathbb{F}_q
  \times \mathbb{F}_q) \to \mathbb{F}_q$

Each of these takes as its first argument a _domain separator_. For the tiered note commitment tree,
we use a domain separator calculated in terms of the _base domain separator_ $\mathbf{D}_0 =
\mathtt{blake2b}(\mathtt{"penumbra.tct"})$ interpreted in little-endian order as an element of
$\mathbb{F}_q$, i.e. the following hash output from
[BLAKE2](https://datatracker.ietf.org/doc/html/rfc7693):

```plain_text
0x197e501077d94b004b29e91196b9da397b8acbc98ac2d13d9099ad99f5215e490f171a0406f223ed25bafe4bc0451b649ba4b3fe0374d4a0b1ffd2ead37f531e
```

...interpreted as a (large) integer in little-endian order, and reduced by the modulus of
$\mathbb{F}_q$.

In terms of this base domain separator, we construct a separate domain separator to use for each
_height_ of node or leaf in the tree.

$$\mathbf{D}_{height} = \mathbf{D}_0 + height$$

We then define the hash functions for leaves and nodes in terms of the original $\mathtt{hash_1}$ and
$\mathtt{hash_4}$ functions from Poseidon:

- $\mathtt{hash_{leaf}}(commitment : \mathbb{F}_q) = \mathtt{hash_1}(\mathbf{D}_0,
commitment)$
- $\mathtt{hash_{node}}(height : \mathbb{N}, children : \mathbb{F}_q \times
\mathbb{F}_q \times \mathbb{F}_q \times \mathbb{F}_q) = \mathtt{hash_4}(\mathbf{D}_{height},
children)$

Having defined them, we will now exclusively use $\mathtt{hash_{leaf}}$ and $\mathtt{hash_{node}}$.

### Hashes of Nodes

The hash of a node is dependent on three things:

1. its _height_,
2. whether it is on the _frontier_ of the tree, and
3. the hashes of its children.

#### The Height of a Node

The height of a leaf is defined as zero, and the height of a node is defined as one greater than the
height of its children, all of whom will always have the same height. As a consequence, the lowest
node in the tree has height 1.

#### Frontier-Dependent Padding

Recall that each node may have any of $\{1 \dots 4\}$ children, inclusive. However, recall the node
hash function $\mathtt{hash_{node}} : \mathbb{N} \times (\mathbb{F}_q \times \mathbb{F}_q \times
\mathbb{F}_q \times \mathbb{F}_q) \to \mathbb{F}_q$ is of fixed arity: it requires precisely a node height and 4
child hashes. In order to take the hash of a node, we need to _pad_ its list of children with some
padding element $\mathbf{P}$:

$$
\begin{align}
\mathtt{pad}_4(\mathbf{P}, & [a]) & =\ \ & (a, \mathbf{P}, \mathbf{P}, \mathbf{P}) \newline
\mathtt{pad}_4(\mathbf{P}, & [a, b]) & =\ \ & (a, b, \mathbf{P}, \mathbf{P}) \newline
\mathtt{pad}_4(\mathbf{P}, & [a, b, c]) & =\ \ & (a, b, c, \mathbf{P}) \newline
\mathtt{pad}_4(\mathbf{P}, & [a, b, c, d]) & =\ \ & (a, b, c, d) \newline
\end{align}
$$

In order to bind the root hash of the tree to the fact of a given subtree (block, epoch, etc.) being
completed or unfinished, we use a different padding element for computing the hash of nodes on the
_frontier_. A node is considered on the _frontier_ of the tree if __either__:

- it is the root node of the tree, or
- its parent node is on the frontier of the tree and it is the rightmost child of its parent.

If a node is on the frontier, we use the padding element $\mathbf{P}_\mathtt{frontier} :
\mathbb{F}_q = 0$. Otherwise, we use the padding element $\mathbf{P}_\mathtt{complete} :
\mathbb{F}_q = 1$.

#### Computing Node Hashes

As noted [above](#tiered-structure), every node has at least 1 child, so the hash of an empty node
is undefined.

The hash of a node with more than zero children is parameterized by a padding element $\mathbf{P}$
which will be used to pad the frontier of the subtree of this node:

$$
node\mathtt{.hash}(\mathbf{P} : \mathbb{F}_q) = \mathtt{hash_{node}}\left(node\mathtt{.height},
\mathtt{pad}_4(\mathbf{P}, node\mathtt{.hash_{children}(\mathbf{P})})\right)
$$

where the method $\mathtt{node.hash_{children}}$ is defined as:

$$
\begin{align}
& node\mathtt{.hash_{children}}(\mathbf{P} : \mathbb{F}_q) =\ \mathbf{case}\ node\mathtt{.children}\ \mathbf{of}\newline
& \ \ \ \ \ [a] \Rightarrow [a\mathtt{.hash(\mathbf{P})}]\newline
& \ \ \ \ \ [a, b] \Rightarrow [a\mathtt{.hash({\mathbf{P}_\mathtt{complete})}}, b\mathtt{.hash(\mathbf{P})}]\newline
& \ \ \ \ \ [a, b, c] \Rightarrow [a\mathtt{.hash({\mathbf{P}_\mathtt{complete})}},
b\mathtt{.hash({\mathbf{P}_\mathtt{complete})}}, c\mathtt{.hash(\mathbf{P})}]\newline
& \ \ \ \ \ [a, b, c, d] \Rightarrow [a\mathtt{.hash({\mathbf{P}_\mathtt{complete})}},
b\mathtt{.hash({\mathbf{P}_\mathtt{complete})}}, c\mathtt{.hash({\mathbf{P}_\mathtt{complete})}}, d\mathtt{.hash(\mathbf{P})}]
\end{align}
$$

That is to say, $\mathtt{node.hash_{children}}$ implements the [frontier-dependent
padding](#frontier-dependent-padding) as described above.

### Hashes of Tiers

The hash of a tier also depends on whether it is on the frontier.

$$
\begin{align}
& tier\mathtt{.hash}(\mathbf{P} : \mathbb{F}_q) =\ \mathbf{case}\ tier\ \mathbf{of}\newline
& \ \ \ \ \ \mathtt{Tier}(\emptyset) \Rightarrow \mathbf{P}\newline
& \ \ \ \ \ \mathtt{Tier}(node) \Rightarrow node\mathtt{.hash(\mathbf{P})}
\end{align}
$$

### Hashes of Leaves

Leaves are easy to hash; every leaf's hash is the $\mathtt{hash_{leaf}}$ of its contained
commitment.

$$
\mathit{leaf}\mathtt{.hash}(\_ : \mathbb{F}_q) = \mathtt{hash_{leaf}}(\mathit{leaf})
$$

The hash of a leaf does not depend on whether it is on the frontier or not, so the padding is
ignored.

### Hashes of Trees

The root hash of an entire tree is the hash of its topmost tier using the padding hash
$\mathbf{P}_\mathtt{frontier}$:

$$
\mathit{tree}\mathtt{.root()} = \mathit{tree}\mathtt{.hash(\mathbf{P}_\mathtt{frontier})}
$$

## Sparsity

A client of the tree does not usually ever need to produce proofs for the vast majority of
commitments which have been bound into it. In the case of a full node, proofs need never be
produced; only the root hash need be updated. In the case of a client, only proofs of inclusion for
commitments relevant to that clients fragment of the global state need ever be produced.

The construction above represents every commitment explicitly, which means that if interpreted
literally, it would result in a large amount of storage usage. Instead, we would like to make the
tree _sparse_, by summarizing nodes which contain information that is considered irrelevant to a
particular user.

This can be done via a modification to the construction of nodes: specifically, a new kind of node
can be introduced which holds a _hash value_ rather that a list of children. The hash of such a node
is defined to be exactly the contained hash value.

Given a set $R$ of commitments which are desired to be remembered, we can prune the tree to
summarize irrelevant parts of it.

Pruning a leaf replaces the leaf by its hash if the leaf is not in the remembered set $R$:

$$
\begin{align}
\mathit{leaf}\mathtt{.prune}(R)\ & \mathbf{if}\ \mathit{leaf} \in R = \mathit{leaf}\\
\mathit{leaf}\mathtt{.prune}(R)\ & \mathbf{if}\ \mathit{leaf} \notin R = \mathit{leaf}\mathtt{.hash()}\\
\end{align}
$$

Pruning a node replaces the node by its hash if, when pruning all of its children, those children
are all hashes rather than nodes. Otherwise, it merely prunes its children, but preserves itself,
because there is at least one child of interest.

$$
\begin{align}
\mathit{node}\mathtt{.prune}(R)\ & \mathbf{if}\ (\exists \mathit{child} \in
\mathit{pruned}, \mathit{child} \notin \mathbb{F}_q) =
\mathtt{Node}(\mathit{pruned})\\
\mathit{node}\mathtt{.prune}(R)\ & \mathbf{if}\ (\forall \mathit{child} \in
\mathit{pruned}, \mathit{child} \in \mathbb{F}_q) = \mathit{node}\mathtt{.hash}()\\
& \mathbf{where}\ \mathit{pruned} = \mathit{node}\mathtt{.children.map}(\mathit{child} \Rightarrow \mathit{child}\mathtt{.prune(R)})
\end{align}
$$

Pruning a tier consists of pruning the underlying node, and if it results in a hash, returning that
hash instead of the original tier.

In the above presentation, the padding hash necessary to calculate hashes has been elided for
simplicity of illustration, but when calculating hashes the correct padding hash must be used as
described above.

This strategy of summarization will not change any of the hash values of any node in the tree that
remains in the tree, because nodes are only ever replaced with their own hash values.
