# Tiered Note Commitment Tree

## Motivation and Relevant Context

Since transactions in Penumbra are shielded, an output of a transaction is a cryptographic
commitment to a [note](../concepts/notes_nullifiers_trees.md), not a note itself. These note
commitments are stored in the tiered commitment tree described in this section, which is replicated
across all nodes and clients.

A client spends a note by using the note commitment tree to produce a (zero knowledge) proof that
the note's commitment was included in the tree, using their spending key to demonstrate that they
are authorized to spend that note, and revealing the note's unique nullifier, to prevent the same
note from ever being spent again.

In this section, we will focus on the design of a commitment tree which enables it to be efficiently
replicated across nodes and clients, and to produce these zero-knowledge proofs of inclusion
required to spend notes.

Penumbra, like many blockchains, divides time into _epochs_, each of which is divided into _blocks_,
each of which contains some number of _transactions_. From the perspective of the note commitment
tree, the only salient aspect of a transaction is its list of _outputs_. Each output contains a
commitment to a specific note. The note commitment tree's purpose is to store all of these
commitments in a way that allows proofs of inclusion to be generated by the client for any unspent
note commitment they possess.

In order to build zero-knowledge proofs of inclusion in the tree, it needs to use a hash function
compatible with the SNARK system in use. While the [Poseidon hash function](./poseidon.md) used in
the tree is friendly to use in SNARKs, it is approximately 1,000 times more expensive to compute in
software than ordinary, non-SNARK-friendly hashes. As a result, the computation of hashes dominates
the cost of any note commitment tree design. In order to allow for fast synchronization, the
efficient note commitment tree used in Penumbra is:

- __tiered__, allowing the root hash of a block or an epoch to be added at the same cost as an
  individual commitment, which means the client can skip over blocks or epochs containing nothing of
  interest to them while computing many orders of magnitude fewer hashes; and
- __sparse__, representing only the information necessary to construct the proofs for the client (or
  in the case of the node, the minimum information necessary to compute new root hashes, because
  nodes never need to create proofs themselves), and not information pertaining to note commitments
  unrelated to a given client.

## The Rest Of This Section

1. We first specify the [tiered structure](#tiered-structure) of the tree without describing anything
about hashing as a function from epochs full of blocks full of commitments;
2. Then, we specify the [hashing](#hashing-nodes) of each node in the tree as an inductive function
on the tree structure;
3. Finally, we describe how the tree can be made [sparse](#sparsity) by describing a modification to
the original construction algorithm, and showing how this modification does not change the hashes of
any nodes which remain in the tree.

## Tiered Structure

At any given moment in time, the aggregate of all note commitments produced in the history of the
chain can be thought of as a triply-nested sequence (an _eternity_) of sequences (_epochs_) of
sequences (_blocks_) of note commitments. The tiered commitment tree represents these triply-nested
sequences as triply-nested tiers.

The entire commitment tree consists of three tiers, each of which is 8 levels tall:

- The entire commitment tree consists of a top-level [_tier_](#tiers) (which we call an _eternity_),
which contains 8 nested levels of [_nodes_](#nodes);
- The children of the bottom-most [_nodes_](#nodes) in an eternity are [_tiers_](#tiers) (which we
  call _epochs_), which each contain 8 nested levels of [_nodes_](#nodes).
- The children of the bottom-most [_nodes_](#nodes) in an epoch are [_tiers_](#tiers) (which we call
  _blocks_), which each contain 8 nested levels of [_nodes_](#nodes).
- The children of the bottom-most [_nodes_](#nodes) in a block are [_leaves_](#leaves) that contain
  one commitment each.

```text
Eternity┃           ╱╲ ◀───────────── Eternity Root
    Tree┃          ╱││╲
        ┃         * ** *           ╮
        ┃      *   *  *   *        │ 8 levels
        ┃   *     *    *     *     ╯
        ┃  ╱╲    ╱╲    ╱╲    ╱╲
        ┃ ╱││╲  ╱││╲  ╱││╲  ╱││╲ ◀─── Epoch Root
                     ┌──┘
                     │
                     │
   Epoch┃           ╱╲ ◀───────────── Epoch Root
    Tree┃          ╱││╲
        ┃         * ** *           ╮
        ┃      *   *  *   *        │ 8 levels
        ┃   *     *    *     *     ╯
        ┃  ╱╲    ╱╲    ╱╲    ╱╲
        ┃ ╱││╲  ╱││╲  ╱││╲  ╱││╲ ◀─── Block Root
                 ▲
                 └───┐
                     │
                     │
   Block┃           ╱╲ ◀───────────── Block Root
    Tree┃          ╱││╲
        ┃         * ** *           ╮
        ┃      *   *  *   *        │ 8 levels
        ┃   *     *    *     *     ╯
        ┃  ╱╲    ╱╲    ╱╲    ╱╲
        ┃ ╱││╲  ╱││╲  ╱││╲  ╱││╲ ◀─── Block Leaf
                                      = Note Commitment
```

As a consequence of this structure, the maximum capacity of a tier is $4^8 = 65,536$, and the
maximum capacity of the entire tree is $4^{3 \cdot 8} = 281,474,976,710,656$.

### Structural Definitions

#### Tiers

A tier is either _empty_ or it is a [_node_](#nodes).

#### Nodes

A node in a tree contains a _non-empty_ list of up to four _children_, all of whom must be the same
type of thing (either a [tier](#tiers) or a [leaf](#leaves)). If a node has an $n$th child (for $n > 0$), it must
have an $(n - 1)$th child (there cannot be gaps in the list of children).

Every node must be _left-to-right filled_:

- a leaf is always left-to-right filled;
- a node is left-to-right filled if all of its children except its rightmost child are _full_ and
  its rightmost child is left-to-right filled; and
- a tier is left-to-right filled if it is not empty and the node it contains is left-to-right filled.

Where _full_ is defined as:

- a leaf is always full;
- a node is full if it has exactly four children and all its children are full; and
- a tier is full if it is not empty and the node it contains is full.

Note that _full_ subsumes _left-to-right filled_: everything that is full is also left-to-right filled.

#### Leaves

A leaf of a tree contains a single commitment.

## Construction

As noted above, the history of all commitments at any point in time is a triply-nested sequence of
commitments, representing epochs, each of which has some number of blocks, each of which has
some number of commitments, each ordered at every level chronologically. We can construct a tiered
commitment tree from this triply nested sequence of commitments by iterating an algorithm to
construct a single tier from a single sequence of items three times, to reduce a triply-nested
sequence of commitments to a triply-nested tiered tree.

We define a function $\mathtt{tier}_\tau : [\tau] \to \mathtt{Tier}_\tau$ which converts a sequence of items of
type $\tau$ to a tier whose bottom-most nodes have children of type $\tau$:

- if the sequence is empty, return the empty tier;
- otherwise, do the following exactly 8 times:
  - in left to right order, greedily partition the sequence into chunks of at most 4 items, so
    that all but the last chunk has exactly 4 items, and the last chunk has at most 4 items;
  - for each chunk, construct a single node from it; and
  - unless done with the 8 iterations, repeat again, starting with this sequence of nodes (which is
    now shorter by about a factor of 4)
- if the input sequence was less than $4^8$ items long, the resultant sequence will now contain
  exactly one element: return that element.

Constructing the entire tree requires mapping the $\mathtt{tier}$ function over the triply-nested
sequence:

$$
\begin{align}
& \mathtt{tree} : [[[\mathbb{F}_q]]] \to
\mathtt{Tier}_{\left(\mathtt{Tier}_{\left(\mathtt{Tier}_{(\mathbb{F}_q)}\right)}\right)} \\
& \mathtt{tree}(\mathtt{eternity}) =\\
& \ \ \ \ \mathtt{tier}_{\left(\mathtt{Tier}_{\left(\mathtt{Tier}_{(\mathbb{F}_q)}\right)}\right)}\left(\mathtt{eternity.map}(\lambda \mathtt{epoch} \to \mathtt{tier}_{\left(\mathtt{Tier}_{(\mathbb{F}_q)}\right)}(\mathtt{epoch.map}(\lambda \mathtt{block} \to
\mathtt{tier}_{(\mathbb{F}_q)}(\mathtt{block})))))\right)
\end{align}
$$

where the $map$ function applies a function to each element of a sequence.

## Hashing Nodes

Each commitment is represented by a single element from the $\mathbb{F}_q$ field of
[BLS12-377](https://docs.rs/ark-ed-on-bls12-377/0.3.0/ark_ed_on_bls12_377/). The [Poseidon for
BLS12-377](./poseidon.md) hash function is defined over that same field.

### Elementary Hashes and Domain Separators

We define the hash of each node in the tree in terms of two arities of the Poseidon hash function:

- $\mathtt{hash_1} : \mathbb{F}_q \times \mathbb{F}_q \to \mathbb{F}_q$
- $\mathtt{hash_4} : \mathbb{F}_q \times (\mathbb{F}_q \times \mathbb{F}_q \times \mathbb{F}_q
  \times \mathbb{F}_q) \to \mathbb{F}_q$

Each of these takes as its first argument a _domain separator_. For the tiered note commitment tree,
we use a domain separator calculated in terms of the _base domain separator_ $\mathbf{D}_0 =
\mathtt{blake2b}(\mathtt{"penumbra.tct"})$ interpreted in little-endian order as an element of
$\mathbb{F}_q$, i.e. the following hash output from
[BLAKE2](https://datatracker.ietf.org/doc/html/rfc7693):

```plain_text
0x197e501077d94b004b29e91196b9da397b8acbc98ac2d13d9099ad99f5215e490f171a0406f223ed25bafe4bc0451b649ba4b3fe0374d4a0b1ffd2ead37f531e
```

...interpreted as a (large) integer in little-endian order, and reduced by the modulus of
$\mathbb{F}_q$.

In terms of this base domain separator, we construct a separate domain separator to use for each
_height_ of node or leaf in the tree.

$$\mathbf{D}_\mathtt{height} = \mathbf{D}_0 + \mathtt{height}$$

We then define the hash functions for leaves and nodes in terms of the original $\mathtt{hash_1}$ and
$\mathtt{hash_4}$ functions from Poseidon:

- $\mathtt{hash_{leaf}}(\mathtt{commitment} : \mathbb{F}_q) = \mathtt{hash_1}(\mathbf{D}_0,
\mathtt{commitment})$
- $\mathtt{hash_{node}}(\mathtt{height} : \mathbb{N}, \mathtt{children} : \mathbb{F}_q \times
\mathbb{F}_q \times \mathbb{F}_q \times \mathbb{F}_q) = \mathtt{hash_4}(\mathbf{D}_\mathtt{height},
\mathtt{children})$

Having defined them, we will now exclusively use $\mathtt{hash_{leaf}}$ and $\mathtt{hash_{node}}$.

### Hashes of Leaves

Leaves are easy to hash; every leaf's hash is the $\mathtt{hash_{leaf}}$ of its contained commitment.

### Hashes of Nodes

The hash of a node is dependent on three things:

1. its _height_,
2. whether it is on the _frontier_ of the tree, and
3. the hashes of its children.

#### The Height of a Node

The height of a leaf is defined as zero, and the height of a node is defined as one greater than the
height of its children, all of whom will always have the same height. As a consequence, the lowest
node in the tree has height 1.

#### Frontier-Dependent Padding

Recall that each node may have any of $\{1 \dots 4\}$ children, inclusive. However, recall the node
hash function $\mathtt{hash_{node}} : \mathbb{N} \times (\mathbb{F}_q \times \mathbb{F}_q \times
\mathbb{F}_q \times \mathbb{F}_q) \to \mathbb{F}_q$ is of fixed arity: it requires precisely a node height and 4
child hashes. In order to take the hash of a node, we need to _pad_ its list of children with some
padding element $\mathbf{P}$:

$$
\begin{align}
\mathtt{pad}_4(\mathbf{P}, & [a]) & =\ \ & (a, \mathbf{P}, \mathbf{P}, \mathbf{P}) \newline
\mathtt{pad}_4(\mathbf{P}, & [a, b]) & =\ \ & (a, b, \mathbf{P}, \mathbf{P}) \newline
\mathtt{pad}_4(\mathbf{P}, & [a, b, c]) & =\ \ & (a, b, c, \mathbf{P}) \newline
\mathtt{pad}_4(\mathbf{P}, & [a, b, c, d]) & =\ \ & (a, b, c, d) \newline
\end{align}
$$

In order to bind the root hash of the tree to the fact of a given subtree (block, epoch, etc.) being
completed or unfinished, we use a different padding element for computing the hash of nodes on the
_frontier_. A node is considered on the _frontier_ of the tree if __either__:

- it is the root node of the tree, or
- its parent node is on the frontier of the tree and it is the rightmost child of its parent.

If a node is on the frontier, we use the padding element $\mathbf{P}_\mathtt{frontier} :
\mathbb{F}_q = 0$. Otherwise, we use the padding element $\mathbf{P}_\mathtt{complete} :
\mathbb{F}_q = 1$.

#### Computing Node Hashes

As noted [above](#tiered-structure), every node has at least 1 child, so the hash of an empty node
is undefined.

The hash of a node with more than zero children is parameterized by a padding element $\mathbf{P}$
which will be used to pad the frontier of the subtree of this node:

$$
\mathtt{node.hash}(\mathbf{P}) = \mathtt{hash_{node}}\left(\mathtt{node.height},
\mathtt{pad}_4(\mathbf{P}, \mathtt{node.hash_{children}(\mathbf{P})})\right)
$$

where the method $\mathtt{node.hash_{children}}$ is defined as:

$$
\begin{align}
& \mathtt{node.hash_{children}}(\mathbf{P} : \mathbb{F}_q) =\ \mathbf{match}\ \mathtt{node.children}\ \{\newline
& \ \ \ [a] \Rightarrow [\mathtt{a.hash(\mathbf{P})}]\newline
& \ \ \ [a, b] \Rightarrow [\mathtt{a.hash({\mathbf{P}_\mathtt{complete})}}, \mathtt{b.hash(\mathbf{P})}]\newline
& \ \ \ [a, b, c] \Rightarrow [\mathtt{a.hash({\mathbf{P}_\mathtt{complete})}},
\mathtt{b.hash({\mathbf{P}_\mathtt{complete})}}, \mathtt{c.hash(\mathbf{P})}]\newline
& \ \ \ [a, b, c, d] \Rightarrow [\mathtt{a.hash({\mathbf{P}_\mathtt{complete})}},
\mathtt{b.hash({\mathbf{P}_\mathtt{complete})}}, \mathtt{c.hash({\mathbf{P}_\mathtt{complete})}}, \mathtt{d.hash(\mathbf{P})}]\newline
& \}
\end{align}
$$

That is to say, $\mathtt{node.hash_{children}}$ implements the [frontier-dependent
padding](#frontier-dependent-padding) as described above.

### Hashes of Tiers



## Sparsity
